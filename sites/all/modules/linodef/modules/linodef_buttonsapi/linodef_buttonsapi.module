<?php
// $Id: linodef_buttonsapi.module,v 1.1.2.2 2008/11/30 13:00:31 roidanton Exp $

/**
 * @file
 * Provides data with Linodef tags for editorbuttons and creates pages & forms for buttons.
 *
 * 1) Retrieve the data for Linodef submodules that adds (or provides functions for) contrib editor buttons and return a formatted list of items with links.
 * 2) Buttons
 *  a. Provide a popup window.
 *  b. Provide autocomplete button.
 * 4) Admin settings.
 *
 * @package Linodef
 * @author Roi Danton
 */

/**
 * 1) Retrieve the data for Linodef submodules that adds (or provides functions for) contrib editor buttons and return a formatted list of items with links.
 */

/**
 * Create a formatted list of items with links.
 *
 * Adds the key 'content' containing the itemlink to the output of linodef_buttonsapi_rawdata().
 *
 * @param $calling_module
 *      The name of the module that calls this function. Needed for javascript file and function to use when clicked on an item.
 * @param string $drupal_element
 *      The element to retrieve the data from. This has to be a supported element type. See Linodef advanced help.
 * @param array $option_string_path
 *      A string containing tag options.
 * @return array
 *          - content: The html list with the items or a message ready for Javascript.
 *          - for the other keys see return value of linodef_buttonsapi_rawdata()
 *
 * @see linodef_buttonsapi_rawdata()
 */
function linodef_buttonsapi_itemlist($calling_module, $drupal_element, $option_string_path) {
    // Retrieve the data.
    $button_data = linodef_buttonsapi_rawdata($drupal_element, $option_string_path);
    
    if (is_array($button_data)) {
        $output = $button_data;
        // Format output.
        foreach ($button_data['data'] as $value) {
            // l() shows character binary for some character, not applicable here. $links[] = l($value['desc'], '#', array('attributes' => array( 'onclick' => $calling_module .'_onclick(\''. $value['tag'] .';return false;\')' )));
            $links[] = '<a href="#" title="'. $value['tag'] .'" onclick="'. $calling_module .'_onclick(\''. $value['tag'] .'\');return false;">'. $value['desc'] .'</a>';
        }
        $output['content'] = theme('item_list', $links);
    }
    else {
        // Likely a hint or warning message, e.g. when contenttype not found or similar.
        $output['content'] = drupal_to_js($button_data);
    }
    return $output;
}

/**
 * Choose which method to use to get the data.
 *
 * Furthermore here the string is set for the tag which includes no links. Show terms by contenttype removed as user should use vid instead.
 *
 * @param string $drupal_element
 *      The element to retrieve the data from. This has to be a supported element type. See Linodef advanced help.
 * @param array $option_string_path
 *      A string containing tag options, separated by "_". Following options are supported, other option don't do anything and no error message is returned:
 *      - no_link: If true, a "no link" marker will be added to the tag, so the embedded text is not linked.
 *      - translation: If set the helper functions will check if the node has a translated node in the language this value has (e.g. de, en, es etc).
 * @return
 *      array
 *          - data: the node/field/vocab data
 *              - tag: the tag to be inserted
 *              - desc: the description for the editor button
 *          - name: the label/name of the node/field/vocab
 *          - element type
 *          - element
 *          - options: Array containing the linodef tag options or empty string.
 *      string with error message
 *
 * @see _linodef_buttons_getfieldsbyfieldname(), _linodef_buttons_gettermsbyvid(), _linodef_buttons_getnodesbycontenttype()
 */
function linodef_buttonsapi_rawdata($drupal_element, $option_string_path) {
    include_once(drupal_get_path('module', 'linodef_buttonsapi') .'/includes/linodef_buttonsapi.inc');

    $options = linodef_buttonsapi_validate_tagoptions($option_string_path);
    $option_string = $options ? ','. implode(',', $options) : '';

    if (substr($drupal_element, 0, 6) == "field_") {
        $output = _linodef_buttonsapi_getfieldsbyfieldname($drupal_element, $option_string);
    }
    elseif (preg_match("@([0-9]+)@", $drupal_element)) {
        // Remove tag options that are not needed for terms: translation.
        if ($options['translation']) { unset($options['translation']); }
        $option_string = preg_replace("@,translation=([a-zA-Z]{2})@", "", $option_string);
        $output = _linodef_buttonsapi_gettermsbyvid($drupal_element, $option_string);
    }
    else {
        $output = _linodef_buttonsapi_getnodesbycontenttype($drupal_element, $option_string);
    }
    if (is_array($output)) {
        // If set by terms ID.
        if (is_array($output['options'])) {
            $output['options'] += $options ? $options : array();
        }
        else {
            $output['options'] = $options ? $options : NULL;
        }
    }
    return $output;
}

/**
 * Creates an array of Linodef tag options.
 * Only keeps valid options: Types in options (nid, tid) are excluded.
 *
 * @param string $option_string
 * @return
 *      array with validated Linodef tag options or 0 if parameter is empty.
 *          - key: option name
 *          - value: option as used in the tag
 *
 * @see linodef_buttonsapi_tagoptions_to_path()
 */
function linodef_buttonsapi_validate_tagoptions($option_string) {
    if (is_string($option_string) && !empty($option_string)) {
        if (strpos($option_string, ',') !== FALSE) {
            $options_path = explode(',', $option_string);
        }
        // If modified by linodef_buttonsapi_tagoptions_to_path().
        elseif (strpos($option_string, '_') !== FALSE) {
            $options_path = explode('_', $option_string);
        }
        // If only one option and therefore no separator.
        else {
            $options_path[] = $option_string;
        }
        // Only options needs validation, types are inherited from drupal_element.
        if (is_array($options_path)) {
            foreach ($options_path as $value) {
                if ($value == 'nolink') {
                    $output['nolink'] = $value;
                }
                if (substr($value, 0, 11) == 'translation') {
                    // Revert translation layout if modified by linodef_buttonsapi_tagoptions_to_path().
                    $output['translation'] = str_replace('-', '=', $value);
                }
            }
        }
    }
    if (!$output) {
        $output = FALSE;
    }
    return $output;
}

/**
 * Converts a linodef option array into a valid path.
 *
 * @param array $options
 * @return
 *      string which looks like a file path
 *
 * @see linodef_buttons_bueditor_buttons()
 */
function linodef_buttonsapi_tagoptions_to_path($options) {
    $output = implode('_', $options);
    // Make option layout compatible with path: translation.
    $output = str_replace('=', '-', $output);
    return $output;
}

/**
 * 2) Buttons.
 *  a) Linodef Pages: Popup window.
 *  b) Linodef Forms: Autocomplete.
 */

function linodef_buttonsapi_buttoncall($button_type, $calling_module, $drupal_element, $option_string_path, $button_options) {
    global $base_url;

    switch ($button_type) {
    case 'autocomplete':
        // Autocomplete doesn't work in another form therefore we need external button or popup.
        // The path has to be linodef/popup-ac/modulename/drupal_element/no_link, e.g. linodef/popup-ac/linodef_buttons_bueditor/story/0.
        // The function to open the popup window requires the width & height of the window.
        return 'js: linodef_buttonsapi_popup("'. $base_url .'/linodef/popup-ac/'. $modulename .'/'. $drupal_element .'/'. $option_string_path .'", 600, 500);';
        break;
    case 'popup':
        return 'js: linodef_buttonsapi_popup("'. $base_url .'/linodef/popup/'. $modulename .'/'. $drupal_element .'/'. $option_string_path .'", 600, 500);';
        break;
    }
}

/**
 * Implementation of hook_menu().
 */
function linodef_buttonsapi_menu() {
  // Popup with item list.
  $items['linodef/popup/%/%/%'] = array(
      'type' => MENU_CALLBACK,
      'title' => 'Linodef popup',
      'page callback' => '_linodef_buttonsapi_popup',
      'page arguments' => array(1, 2, 3, 4),
      'file' => 'linodef_buttonsapi.pages.inc',
      'file path' => drupal_get_path('module', 'linodef_buttonsapi') .'/theme',
      'access arguments' => array('access content'),
  );
  // Popup with autocomplete button. Done that way because autocomplete mustn't be a part of the editors form.
  $items['linodef/popup-ac/%/%/%'] = array(
      'type' => MENU_CALLBACK,
      'title' => 'Linodef autocomplete popup',
      'page callback' => '_linodef_buttonsapi_popup',
      'page arguments' => array(1, 2, 3, 4),
      'file' => 'linodef_buttonsapi.pages.inc',
      'file path' => drupal_get_path('module', 'linodef_buttonsapi') .'/theme',
      'access arguments' => array('access content'),
  );
  // Required for autocomplete list.
  $items['linodef/autocomplete'] = array(
    'type' => MENU_CALLBACK,
    'title' => 'Linodef autocomplete',
    'page callback' => '_linodef_buttonsapi_autocomplete',
    'access arguments' => array('access content'),
  );
  return $items;
}

/**
 * Implementation of hook_theme().
 */
function linodef_buttonsapi_theme() {
  // Popup window for editorbuttons-api.
  $hooks['linodef_buttonsapi_popup'] = array(
    'arguments' => array('content' => NULL,
                         'explanation' => NULL,
                         'calling_module' => NULL,
                         'element_name' => NULL,
                         'title' => 'Linodef popup',
                          ),
    'file' => 'linodef_buttonsapi.pages.inc',
    'path' => drupal_get_path('module', 'linodef_buttonsapi') .'/theme',
    'template' => 'linodef-buttonsapi-popup',
  );
  return $hooks;
}

/**
 * Implementation of hook_form().
 *
 * Create autocomplete textfield.
 */
function linodef_buttonsapi_autocomplete_form($form_state, $calling_module, $drupal_element, $no_link) {
  $form['linodef_buttonsapi_autocomplete'] = array(
    '#type' => 'textfield',
    '#title' => '',
    '#default_value' => '',
    '#autocomplete_path'  => 'linodef/autocomplete/'. $calling_module .'/'. $drupal_element .'/'. $no_link,
    /* maybe in a later version with Ajax '#ahah' => array(
      'wrapper' => $editor_textfield_id,
      'method' => 'append',
    ),*/
  );
  $form['linodef_buttonsapi_autocomplete_submit'] = array(
    '#type' => 'submit', 
    '#value' => t('Submit'),
  );
  return $form;
}

/**
 * Validate the autocomplete form.
 */
function linodef_buttonsapi_autocomplete_form_validate($form, &$form_state) {
  if ($form_state['values']['linodef_buttonsapi_autocomplete'] == '') {
    form_set_error('', t('Enter or select a tag that you want to include into your text.'));
  }
  elseif ($button_data = variable_get('linodef_buttonsapi_buttondata', FALSE)) {
    // variable_del('linodef_buttonsapi_buttondata'); // Variable created on popup display again either.
    $success = FALSE;
    foreach ($button_data as $value) {
        // Allow tags with additional user input: comment or additional options (last one works only if comment not set).
        $value['tag'] = strtr($value['tag'], array(']' => ''));
        if (strpos($form_state['values']['linodef_buttonsapi_autocomplete'], $value['tag']) !== FALSE && substr($form_state['values']['linodef_buttonsapi_autocomplete'], -1) == ']') {
            $success = TRUE;
        }
    }
    if ($success === FALSE) {
        form_set_error('', t('Tag %tag is not valid or not part of this button. Either select another tag from the autocomplete list, use a different editor button or paste the tag you have entered manually into your text.', array('%tag' => $form_state['values']['linodef_buttonsapi_autocomplete'])));
    }
  }
}

/**
 * Submit the autocomplete form.
 *
 * @see template_preprocess_linodef_buttonsapi_popup()
 */
function linodef_buttonsapi_autocomplete_form_submit($form, &$form_state) {
    drupal_set_message(t("The tag %tag has been submitted. In case it doesn't appear in your text don't worry but manually copy & paste the tag.", array('%tag' => $form_state['values']['linodef_buttonsapi_autocomplete'])));
    // Variable helping to submit the tag to the editors textarea.
    variable_set('linodef_buttonsapi_submitted_tag', $form_state['values']['linodef_buttonsapi_autocomplete']);
}

/**
 * Autocomplete Form callback: Retrieve a pipe delimited string of autocomplete suggestions for existing elements.
 *
 * Parameters sent from #autocomplete_path at hook_form(). The parameter after them is the inserted text by the user.
 *
 * @param $calling_module
 *      The name of the module that calls this function. Needed for javascript file and function to use when clicked on/submitting an item.
 * @param string $drupal_element
 *      The element to retrieve the data from. This has to be a supported element type. See Linodef advanced help.
 * @param $no_link
 *      If true, a "no link" marker will be added to the tag, so the embedded text is not linked.
 * @param string $string
 *      String the user entered in textfield.
 */
function _linodef_buttonsapi_autocomplete($calling_module, $drupal_element, $no_link, $string = '') {
    $matches = array();
    $button_data = linodef_buttonsapi_rawdata($drupal_element, $no_link);
    foreach ($button_data['data'] as $value) {
        if (!empty($string)) {
            if (strpos($value['desc'], $string) !== FALSE) {
                $matches[$value['tag']] = '<div class="reference-autocomplete">'. $value['desc'] .'</div>';
            }
        }
    }
    print drupal_to_js($matches);
    exit();
}

/**
 * 4) Admin settings.
 *
 * Implementation of hook_form_[form_id]_alter().
 *
 * Extends Linodef settings with Linodef Buttons API settings.
 */
function linodef_buttonsapi_form_linodef_theme_settings_alter(&$form, $form_state) {
  include_once(drupal_get_path('module', 'linodef_buttonsapi') .'/theme/linodef_buttonsapi.admin.inc');
  _linodef_buttonsapi_form_linodef_theme_settings_alter($form, $form_state);
}